

# This file was *autogenerated* from the file ReedSolomon.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8)
import random
from argparse import ArgumentParser
parser=ArgumentParser()

parser.add_argument("-v", "--verbose",action="store_true")
parser.add_argument("-n", "--length", default="20")
parser.add_argument("-k", "--dimension", default="5")
parser.add_argument("-p", "--characteristic", default="997")
parser.add_argument("-d", "--fielddimension", default="1")
parser.add_argument("-a", "--algo", default="bw")
parser.add_argument("-m", "--multiplicity", default="1")
parser.add_argument("-i", "--iterations", default="1")

args=parser.parse_args()

p=Integer(args.characteristic)
d=Integer(args.fielddimension)

n=Integer(args.length)
k=Integer(args.dimension)




class RandRS:
	def __init__(self, p, d, n, k, Verbose=True):
		self.p=p
		self.d=d
		self.n=n
		self.k=k
		self.field=GF((p,d), "T")
		self.x=vector(self.field, [self.field.random_element() for i in range(n)])

		self.M=matrix(self.field, [[self.x[i]**j for i in range(n)] for j in range(k)])
		self.verbose=Verbose

		if self.verbose:
			print(f"Generating Reed Solomon RS_{k}({self.x}) over {self.field} with matrix:")
			print(f"{self.M}")
	
	def Encode(self, m):
		c=vector(self.field, m * self.M)
		if self.verbose:
			print(f"Encoding message {m} into {c}\n")
		return c

		

	def DecodeBerlekampWelch(self, u):
		if self.verbose:
			print(f"Decoding encoded message {u}\n")
		#n+1=n-t+1+t
		variables=PolynomialRing(self.field, self.n+_sage_const_1 , "a")
		R = self.field['X']; (X,) = R._first_ngens(1)

		#les coeffs sont des polynomes en les variables
		L = variables['X, Y']; (X, Y,) = L._first_ngens(2)

		Q=sum([L(variables.gen(i)*X**i) for i in range(n-t)])
		Q+=L(Y)*sum([L(variables.gen(n-t+i)*X**i) for i in range(t+_sage_const_1 )])
	
		#matrice dont les lignes sont les Q(x_i, u_i)
		M=matrix(self.field, [[Q(self.x[i], u[i]).coefficient(variables.gen(j)) for j in range(n+_sage_const_1 )] for i in range(n)])

		SOLS=M.right_kernel()

		#contient les coeffs d'un polynome de la base
		#Ordonné de haut en bas comme coeffs a_i de Q_0 puis a_i-(n-t) de u_i*Q_1 
		if self.verbose:
			print(f"Basis of solutions for Q_0(x_i)+u_i*Q_1(x_i)=0: {SOLS}\n")
		for coeffs in SOLS.basis():
			Q_0=R(list(coeffs[:n-t]))
			Q_1=R(list(coeffs[n-t:]))
			if self.verbose:
				print(f"Q_0={Q_0}, Q_1={Q_1}\n")
			L = R['Y']; (Y,) = L._first_ngens(1)
			Q=Q_0+Y*Q_1

			#R(-Q_0/Q_1)
			#return vector(self.field, Q.roots()[0].coefficients())
			try:
				return vector(self.field, list(R(-Q_0/Q_1)))
			except:
				continue
	def DecodeSudan(self, u, r, l):
		if self.verbose:
			print(f"Decoding encoded message {u}\n")
		nb_vars=(l+_sage_const_1 )*(self.n-r)-(self.k-_sage_const_1 )*((l*(l+_sage_const_1 ))//_sage_const_2 )

		variables=PolynomialRing(self.field, nb_vars, "a")

		#les coeffs sont des polynomes en les variables
		L = variables['T, T_']; (T, T_,) = L._first_ngens(2)

		Q=L(_sage_const_0 )
		last_ind=_sage_const_0 
		for j in range(l+_sage_const_1 ):
			degQj=self.n-r-j*(self.k-_sage_const_1 )-_sage_const_1 
			Q+=L(T_**j)*sum([L(variables.gen(last_ind+i)*T**i) for i in range(degQj+_sage_const_1 )])
			last_ind+=degQj

	
		#matrice dont les lignes sont les Q(x_i, u_i)
		M=matrix(self.field, [[Q(self.x[i], u[i]).coefficient(variables.gen(j)) for j in range(nb_vars)] for i in range(n)])
		
		SOLS=M.right_kernel()

		R = self.field['X']; (X,) = R._first_ngens(1)
		O = R['Y']; (Y,) = O._first_ngens(1)

		if self.verbose:
			print(f"Basis of solutions for Q(x_i,u_i)=0: {SOLS}\n")

		for coeffs in SOLS.basis():
			Pjs=[]
			lowind=_sage_const_0 
			highind=_sage_const_0 
			for j in range(l+_sage_const_1 ):
				highind+=self.n-r-j*(self.k-_sage_const_1 )
				Pjs.append(R(list(coeffs[lowind:highind])))
				lowind=highind
			P=sum([Pjs[j]*Y**j for j in range(l+_sage_const_1 )])
			print(P(X**(k-_sage_const_1 )).degree(), self.n-r)

			if self.verbose:
				print(f"Searching for roots of {P} in {P.parent()}")
			try:
				roots=P.roots()
				return roots
			except:
				continue
		return 

	def DecodeSudanCorr(self, u, r, l):
		ncols=(l+_sage_const_1 )*(self.n-_sage_const_1 )-((self.k-_sage_const_1 )*(l+_sage_const_1 )*l)//_sage_const_2 
		M_tab=[[_sage_const_0 ]*ncols for i in range(self.n)]

		for i in range(n):
			index=_sage_const_0 
			for j in range(l+_sage_const_1 ):
				for s in range(self.n-r-j*(self.k-_sage_const_1 )):
					M_tab[i][index]=u[i]**j*self.x[i]**s
					index+=_sage_const_1 
		R = self.field['X']; (X,) = R._first_ngens(1)
		L = R['Y']; (Y,) = L._first_ngens(1)

		M=matrix(self.field, M_tab)
		S=M.right_kernel()
		coeffs = S.basis()[_sage_const_0 ]

		Q_j=[_sage_const_0 ]*(l+_sage_const_1 )
		Q=_sage_const_0 *X*Y
		index_min=_sage_const_0 
		index_max=self.n-r
		for j in range(l+_sage_const_1 ):
			Q_j[j]=R(list(coeffs[index_min:index_max]))
			index_min=index_max
			index_max+=self.n-r-j*(self.k-_sage_const_1 )
			Q+=Q_j[j]*Y**j
		if self.verbose:
			print(f"\nSearching for roots of {Q} in {Q.parent()}\n")

		return Q.roots()
		
	def DecodeGuruswamiSudan(self, y, r, l, m):
		"""
		inspiré de 

https://github.com/sagemath/sage/blob/develop/src/sage/coding/guruswami_sudan/interpolation.py

		et 

https://en.wikipedia.org/wiki/Guruswami%E2%80%93Sudan_list_decoding_algorithm

		Tout polynome Q(X,Y) de degré m lesté par (1,k-1) s'écrit :

			Q(X,Y)=\sum_{i+(k-1)*j}<=m a_i,j X^iY^j

		On peut ensuite écrire Q(X+a,Y+b)=\sum X^u*Y^uQ^(u,v)(a, b)
		avec 

			Q^(u,v)(X,Y)=\sum_i,j  a_i,j*binom(i,u)*binom(j,v)*X^(i-u)*Y^(j-v)

		On traduit que Q a multiplicité m>= en (a,b) par Q_(u,v)(a,b)=0
		pour tout 0 <= u+v <= m-1. En pratique on associe au monome 
		X^u*Y^v la ligne d'équations de coefficients :
			(a_i,j binom(i,u)*binom(j,v)*a^(i-u)*b^(j-v))_i,j
		tel que i+(k-1)*j<m(n-r)
		"""
		#ncols=(l+1)*(m*self.n-1)-((self.k-1)*(l+1)*l)//2
		#neqs=self.n*(m*(m+1))/2
		def monomials(l, m, k, n, r):
			for j in range(m*(n-r)+_sage_const_1 ):
				for i in range(m*(n-r)-j*(k-_sage_const_1 )):
					yield (i, j)

		lst_monomials=list(monomials(l,m,self.k,self.n,r))

		M_tab=[]
		for (a,b) in zip(self.x, y):
			for u in range(m):
				for v in range(m-u):
					line=[]
					map_line={}
					for monomial in lst_monomials:
						(i, j)=monomial
						if i>=u and j>=v:
							if i>u:
								coeff_i=binomial(i, u) * a**(i-u)
							else:
								coeff_i=_sage_const_1 
							if j>v:
								coeff_j=binomial(j, v) * b**(j-v)
							else:
								coeff_j=_sage_const_1 
						map_line[monomial]=coeff_i*coeff_j
					for monomial in lst_monomials:
						line.append(map_line.get(monomial, _sage_const_0 ))
					M_tab.append(line)


		R = self.field['X']; (X,) = R._first_ngens(1)
		L = R['Y']; (Y,) = L._first_ngens(1)

		M=matrix(self.field, M_tab)
		S=M.right_kernel()
		if self.verbose:
			print(f"Equations to solve: {M.parent()}\n")
			print(f"Kernel of the system: {S}\n")
		coeffs = S.basis()[_sage_const_0 ]


		Q=sum([X**(lst_monomials[i][_sage_const_0 ]) *Y**(lst_monomials[i][_sage_const_1 ]) * coeffs[i] for i in range(_sage_const_0 , len(lst_monomials))])


		if self.verbose:
			print(f"\nSearching for roots of {Q} in {Q.parent()}\n")
		return Q.roots()
		


class Canal:
	def __init__(self, q, n, distribution="uniform", Verbose=True):
		self.distribution=distribution
		self.field=GF(q, "T")
		self.n=n
		self.verbose=Verbose
	def go_through(self, c, t):
		nb_err=random.randrange(_sage_const_0 , t)
		e=[self.field.random_element() for i in range(nb_err)]+[_sage_const_0 ]*(self.n-nb_err)
		random.shuffle(e)
		e=vector(self.field, e)

		if self.verbose:
			print(f"Going through the canal, adding error {e}\n")

		return c+e

		

RS=RandRS(p,d,n,k, Verbose=args.verbose)
C=Canal(p**d, n, Verbose=args.verbose)

iterations=Integer(args.iterations)

if args.algo == "bw":
	print(f"Decoding with Berlekamp-Welch decoder\n")
	t=floor((RS.n-RS.k)/_sage_const_2 )
	for i in range(iterations):
		m=vector(RS.field, [RS.field.random_element() for i in range(RS.k)])
		c=RS.Encode(m)
		decoded=RS.DecodeBerlekampWelch(C.go_through(c, t))
		print(f"Original message: {m}")
		print(f"Decoded message: {decoded}")

elif args.algo == "sudan":
	print(f"Decoding with Sudan decoder (Not working, call -a 'gs' -m 1\n")
	r=floor(RS.n-(RS.n)*sqrt(RS.k/RS.n)*( sqrt(k/n + _sage_const_8 ) - sqrt(k/n) )/_sage_const_2 )
	l=ceil((n-r)/(k-_sage_const_1 )-_sage_const_1 )

	for i in range(iterations):
		m=vector(RS.field, [RS.field.random_element() for i in range(RS.k)])
		c=RS.Encode(m)
		m_=RS.DecodeSudanCorr(C.go_through(c, r), r, l)
		print(f"Original message: {m}")
		print(f"Found the following candidate messages: \n\n{m_}")

elif args.algo == "sudancorr":
	r=floor(RS.n-(RS.n)*sqrt(RS.k/RS.n)*( sqrt(k/n + _sage_const_8 ) - sqrt(k/n) )/_sage_const_2 )
	l=ceil((n-r)/(k-_sage_const_1 )-_sage_const_1 )

	for i in range(iterations):
		m=vector(RS.field, [RS.field.random_element() for i in range(RS.k)])
		c=RS.Encode(m)
		m_=RS.DecodeSudanCorr(C.go_through(c, r), r, l)
		print(f"Original message: {m}")
		print(f"Found the following candidate messages: \n\n{m_}")

elif args.algo == "gs":
	r=floor( RS.n*(_sage_const_1 -sqrt(k/n)) )

	mult=Integer(args.multiplicity)
	l=floor(mult*(n-r)/(k-_sage_const_1 )-_sage_const_1 )

	iterations=Integer(args.iterations)
	for i in range(iterations):
		m=vector(RS.field, [RS.field.random_element() for i in range(RS.k)])
		c=RS.Encode(m)
		m_=[tuple(root[_sage_const_0 ]) for root in RS.DecodeGuruswamiSudan(C.go_through(c,r),r,l,mult)]
		print(f"\nOriginal message: {m}")
		print(f"Found the following candidate messages: \n\n{m_}")










