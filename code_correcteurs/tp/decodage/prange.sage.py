

# This file was *autogenerated* from the file prange.sage
from sage.all_cmdline import *   # import sage library

_sage_const_100 = Integer(100); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_1111 = Integer(1111)#Etant donné une erreur e tq |e|<=w,
#He=s (syndrome). On connait s on veut e
#tq |e|=w. On regarde sur des ens d'infos


#H est de taille n*(n-k)?(ca a l'air)

from sage.coding.code_bounds import entropy, entropy_inverse
import random

n=_sage_const_100 
k=floor(n/_sage_const_2 )
p=_sage_const_2 
m=_sage_const_1 
q=p**m

t_max=floor(n*entropy_inverse(_sage_const_1 -k/n,q))

ssets=Subsets([i for i in range(_sage_const_0 ,n)], n-k)

def Prange(H,s,n,k,w):
	if s==[_sage_const_0 ]*(n-k):
		print(s)
		return [_sage_const_0 ]*(n-k)

	count=_sage_const_0 
	while True:
		count=count+_sage_const_1 
		J=ssets.random_element()
		H_J=H.matrix_from_columns(J)
		#on peut aussi solve_right(s)
		try:
			H_J_inv=H_J**(-_sage_const_1 )
		except:
			#if count%1000==0:
				#print(J," n'est pas un ensemble d'info")
				#print("\n", count, "itérations")
			continue
		e_=H_J_inv*s
		if count%_sage_const_1111 ==_sage_const_0 :
			e=[_sage_const_0 ]*n	
			i=_sage_const_0 
			for j in J:
				e[j]=e_[i]
			i=i+_sage_const_1 
			print("H^-1*s=",e)
		if e_.hamming_weight() == w:
			break
	e=[_sage_const_0 ]*n	
	i=_sage_const_0 
	for j in J:
		e[j]=e_[i]
		i=i+_sage_const_1 
	#print(count)
	return (e,count)

K = GF(q, names=('t',)); (t,) = K._first_ngens(1)
M=MatrixSpace(K,n-k,n)
#print(H,"t_max=", t_max)

#w=random.randint(1,t_max)

#print(e,'\n',e_,'\n',e==e_)

average_it=_sage_const_1 

#for i in range(100):
H=M.random_element()
print(H)
e=vector(K, [_sage_const_1  for i in range(t_max)]+[_sage_const_0 ]*(n-t_max))
random.shuffle(e)
print(e)
print(H*e)

(e_,i)=Prange(H,H*e,n,k,t_max)
average_it=average_it+i

print(vector(K,e_)==e)
	
#average_it=float(average_it/20)
print(average_it)


