

# This file was *autogenerated* from the file prange.sage
from sage.all_cmdline import *   # import sage library

_sage_const_20 = Integer(20); _sage_const_10 = Integer(10); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_1111 = Integer(1111)#Etant donné une erreur e tq |e|<=w,
#He=s (syndrome). On connait s on veut e
#tq |e|=w. On regarde sur des ens d'infos


#H est de taille n*(n-k)?(ca a l'air)

from sage.coding.code_bounds import entropy, entropy_inverse
import random

n=_sage_const_20 
k=_sage_const_10 
p=_sage_const_2 
m=_sage_const_1 
q=p**m

t_max=floor(n*entropy_inverse(_sage_const_1 -k/n,q))

ssets=Subsets([i for i in range(_sage_const_0 ,n)], n-k)

def Prange(H,s,n,k,w):
	if s==[_sage_const_0 ]*(n-k):
		print(s)
		return [_sage_const_0 ]*(n-k)

	count=_sage_const_0 
	while True:
		count=count+_sage_const_1 
		J=ssets.random_element()
		H_J=H.matrix_from_columns(J)
		#on peut aussi solve_right(s)
		try:
			H_J_inv=H_J**(-_sage_const_1 )
		except:
			#if count%1000==0:
				#print(J," n'est pas un ensemble d'info")
				#print("\n", count, "itérations")
			continue
		e_=H_J_inv*s
		if count%_sage_const_1111 ==_sage_const_0 :
			e=[_sage_const_0 ]*n	
			i=_sage_const_0 
			for j in J:
				e[j]=e_[i]
			i=i+_sage_const_1 
			print("H^-1*s=",e)
		if e_.hamming_weight() == w:
			break
	e=[_sage_const_0 ]*n	
	i=_sage_const_0 
	for j in J:
		e[j]=e_[i]
		i=i+_sage_const_1 
	print(count)
	return e

K = GF(q, names=('t',)); (t,) = K._first_ngens(1)
M=MatrixSpace(K,n-k,n)
H=M.random_element()
print(H,"t_max=", t_max)

w=random.randint(_sage_const_1 ,t_max)

e=vector(K, [_sage_const_1  for i in range(t_max)]+[_sage_const_0 ]*(n-t_max))
random.shuffle(e)

e_=Prange(H,H*e,n,k,t_max)

print(e,e_)

